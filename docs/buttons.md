## Управление часами

- [Настройки кнопок](#настройки-кнопок)
- [Сенсорные кнопки](#сенсорные-кнопки)
- [Как, собственно, управлять](#как-собственно-управлять)
- [Взаимодействие с внешним кодом](#взаимодействие-с-внешним-кодом)
- [Смотри так же](#смотри-так-же)

Часы управляются тремя кнопками: **Set** - вход в режимы настроек и сохранение изменений; **Up** - увеличение текущих значений; **Down** - уменьшение текущих значений; Для работы с кнопками достаточно в файле [**clockSetting.h**](clock_setting.md) указать номера пинов, к которым они подключены.

### Настройки кнопок

Предварительные настройки кнопок задаются в блоке **кнопки** файла [**clockSetting.h**](clock_setting.md).

В строке `#define BTN_INPUT_TYPE PULL_UP` задается тип подключения кнопок. Возможные варианты:
- **PULL_UP** - с подтяжкой к VCC, при нажатии на кнопку на пин приходит логический **0**;
- **PULL_DOWN** - с подтяжкой к GND, при нажатии на кнопку на пин приходит логическая **1**;

В строке `#define BTN_TYPE BTN_NO` задается тип кнопки. Возможные варианты:
- **BTN_NO** - кнопка с нормально разомкнутыми контактами;
- **BTN_NC** - кнопка с нормально замкнутыми контактами;

В блоке **настройка параметров кнопок** нужно задать интервал удержания кнопки, интервал антидребезга, период следования "импульсов" (т.е. событий **BTN_LONGCLICK**) при удержании кнопки нажатой и интервал двойного клика кнопки. Интервалы задаются в милисекундах.

Строка `#define USE_BUZZER_FOR_BUTTON` определяет, будет ли озвучиваться каждый клик кнопки. Конечно, для этого в системе должен присутствовать пищалка, и должен быть определен пин, к которому она подключена.

В блоке **пины для подключения кнопок** задаются пины для подключения кнопок. Если предполагается, что какие-то из кнопок не будут использоваться, вместо номера пина нужно указать **-1** (в принципе, я могу понять отсутствие кнопки **Down**, но смысла в удалении остальных кнопок я не вижу :) 

### Сенсорные кнопки

Если вместо обычных тактовых кнопок планируется использование сенсорных кнопок, то следует задать соответствующий тип подключения. Обычно сенсорные кнопки при нажатии выдают логическую **1**, поэтому для них нужно указывать тип **PULL_DOWN**.

Так же можно установить интервал антидребезга равным нулю, потому что дребезгу контактов сенсорные кнопки не подвержены.

Нужно иметь в виду, что у многих сенсорных кнопкок имеется ограничение времени удержания, т.е. удерживать кнопку нажатой дольше 10-12 секунд не получится, она "отожмется" даже если вы не снимете с нее палец. Возможно ли с этим бороться и как именно, зависит от используемого драйвера кнопки.

### Как, собственно, управлять

Вход во все режимы настроек выполняется из режима отображения текущего времени:
- настройки текущего времени и даты (при использовании календаря) - длинный клик кнопкой **Set**;
- настройки будильника (если используется) - двойной клик (или одиночный короткий клик, если используется соответствующая опция) кнопкой **Set**;
- настройки уровней яркости экрана и порог переключения (если используются соответствующие опции) - одновременное удержание нажатыми кнопок **Up** и **Down**; 
- настройка прочих опций - длинный клик кнопкой **Down**;
- изменение настраиваемых опций - кнопки **Up** и **Down**, клик - увеличение/уменьшение на одну единицу, удержание нажатыми - непрерывное изменение опций; перебор опций и сохранение введенных данных - клик кнопкой **Set**;

Подробная инструкция по настройкам лежит [здесь](setting.md).

### Взаимодействие с внешним кодом

 Достаточно указать номера пинов, к которым они подключены, в файле [**clockSetting.h**](clock_setting.md) - библиотека создаст объекты кнопок сама, сама же их будет и опрашивать. Поэтому, если вам нужно обрабатывать события этих кнопок в своем коде, дублирование не требуется.

***Важно!!!** - для корректной работы кнопок их опрос нельзя проводить более, чем один раз за один проход `loop()`. В противном случае есть риск пропуска событий кнопки.*

 Опрос кнопок ведется библиотекой в методе `tick()`. И для использования событий кнопок внешним кодом библиотека имеет соответствующие методы:
```
uint8_t getButtonState(clkButtonType _btn);
```
возвращает текущее состояние или событие кнопки, заданной параметром `_btn` по результату последнего опроса; `_btn` может принимать три значения:
 - `CLK_BTN_SET` - кнопка **Set**;
 - `CLK_BTN_UP` - кнопка **Up**;
 - `CLK_BTN_DOWN` - кнопка **Down**;
 
Возвращаемые данные соответствуют состояниям и событиям кнопки, используемым в библиотеке [**shButton**](https://github.com/VAleSh-Soft/shButton):
```
// ==== состояние кнопки ========================

#define BTN_RELEASED 0 // кнопка отпущена (контакты разомкнуты)
#define BTN_PRESSED 1  // кнопка нажата, но время удержания еще не вышло

// ==== события кнопки ==========================

#define BTN_UP 2       // кнопка только что отпущена
#define BTN_DOWN 3     // кнопка только что нажата
#define BTN_DBLCLICK 4 // двойной клик - второе нажатие до истечения интервала 
                       // двойного клика; если непрерывно щелкать кнопкой, 
                       // будут поочередно выдаваться события BTN_DOWN и BTN_DBLCLICK

// ==== виртуальные события кнопки ==============

#define BTN_ONECLICK 5  // одиночный клик, следует через некоторый интервал 
                        // после нажатия кнопки, если за это время не 
                        // последовал двойной клик или длительное удержание 
                        // кнопки нажатой; по умолчанию событие отключено
#define BTN_LONGCLICK 6 // событие, соответствующее удержанию кнопки дольше 
                        // времени удержания; может быть быть непрерывным 
                        // (по умолчанию), однократным или следовать через 
                        // определенные интервалы
```

Методы
```
clkButtonFlag getButtonFlag(clkButtonType _btnб bool _clear = false);
void setButtonFlag(clkButtonType _btn, clkButtonFlag _flag);
```
позволяют получить и установить соответственно текущие флаги кнопок; флаги могут принимать значения:
 - **CLK_BTN_FLAG_NONE (0)** - флаг кнопки - ничего не делать;
 - **CLK_BTN_FLAG_NEXT (1)** - флаг кнопки - изменить значение;
 - **CLK_BTN_FLAG_EXIT (2)** - флаг кнопки - возврат в режим показа текущего времени;

Если параметр `_clear` в методе `getButtonFlag()` задать равным **true**, то флаг кнопки после считывания будет очищен (установлено значение **CLK_BTN_FLAG_NONE**);

Флаги используются для работы с интерфейсами настроек - времени, даты, будильника и всех доступных опций.
 
Образец обращения к кнопкам см. в примерах, [например](../examples/tm1637/tm1637.ino).

<hr>
 
### Смотри так же
- [Главная страница](../readme.md)
- [Используемые модули RTC](rtc.md)
- [Используемые в часах экраны](displays.md)
- Дополнительные опции:
  - [Календарь](calendar.md)
  - [Будильник](alarm.md)
  - [Регулировка уровней яркости экрана](br_adjust.md)
  - [Отображение температуры](show_temp.md)
  - [Опции для матричных экранов](matrix.md)
- Внешние датчики:
  - [Датчик освещенности](light_sensor.md)
  - [Датчики температуры](temp_sensors.md)
- [Описание файла `clockSetting.h`](clock_setting.md)
- [Взаимодействие с внешним кодом (API библиотеки)](api.md)
- [Руководство по настройкам часов](setting.md)
