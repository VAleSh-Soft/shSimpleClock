## Управление часами

- [Настройки кнопок](#настройки-кнопок)
- [Сенсорные кнопки](#сенсорные-кнопки)
- [Как, собственно, управлять](#как-собственно-управлять)
- [Взаимодействие с внешним кодом](#взаимодействие-с-внешним-кодом)
- [Смотри так же](#смотри-так-же)

Часы управляются тремя кнопками: **Set** - вход в режимы настроек и сохранение изменений; **Up** - увеличение текущих значений; **Down** - уменьшение текущих значений; Для работы с кнопками используется библиотека [**shButton**](https://github.com/VAleSh-Soft/shButton). Отдельно создавать объекты кнопок не нужно, библиотека сделает это сама, если заданы пины для подключения кнопок.

### Настройки кнопок

Предварительные настройки кнопок расположены в блоке **кнопки** файла **clockSetting.h**.

В строке `#define BTN_INPUT_TYPE PULL_UP` задается тип подключения кнопок. Возможные варианты:
- **PULL_UP** - с подтяжкой к VCC, при нажатии на кнопку на пин приходит логический **0**;
- **PULL_DOWN** - с подтяжкой к GND, при нажатии на кнопку на пин приходит логическая **1**;

В строке `#define BTN_TYPE BTN_NO` задается тип кнопки. Возможные варианты:
- **BTN_NO** - кнопка с нормально разомкнутыми контактами;
- **BTN_NC** - кнопка с нормально замкнутыми контактами;

В блоке **настройка параметров кнопок** нужно задать интервал удержания кнопки, интервал антидребезга и период следования "импульсов" (т.е. событий **BTN_LONGCLICK**) при удержании кнопки нажатой. Интервалы задаются в милисекундах.

Строка `#define USE_BUZZER_FOR_BUTTON` определяет, будет ли озвучиваться каждый клик кнопки. Конечно, для этого в системе должен присутствовать пищалка, и должен быть определен пин, к которому она подключена.

В блоке **пины для подключения кнопок** задаются пины для подключения кнопок. Если предполагается, что какие-то из кнопок не будут использоваться, вместо номера пина нужно указать **-1** (в принципе, я могу понять отсутствие кнопки **Down**, но смысла в удалении остальных кнопок я не вижу :) 

### Сенсорные кнопки

Если вместо обычных тактовых кнопок планируется использование сенсорных кнопок, то следует задать соответствующий тип подключения. Обычно сенсорные кнопки при нажатии выдают логическую **1**, поэтому для них нужно указывать тип **PULL_DOWN**.

Так же можно установить интервал антидребезга равным нулю, потому что дребезгу контактов сенсорные кнопки не подвержены.

Нужно иметь в виду, что у многих сенсорных кнопках имеется ограничение времени удержания, т.е. удерживать кнопку нажатой дольше 10-12 секунд не получится, она "отожмется" даже если вы не снимете с нее пальца. Возможно ли с этим бороться и как именно, зависит от используемого драйвера кнопки.

### Как, собственно, управлять

Вход во все режимы настроек выполняется из режима отображения текущего времени:
- настройки текущего времени и даты (при использовании календаря) - длинный клик кнопкой **Set**;
- настройки будильника (если используется) - двойной клик (или одиночный короткий клик, если используется соответствующая опция) кнопкой **Set**;
- настройки уровней яркости экрана и порог переключения (если используются соответствующие опции) - одновременное удержание нажатыми кнопок **Up** и **Down**; 
- настройка прочих опций - длинный клик кнопкой **Down**;
- изменение настраиваемых опций - кнопки **Up** и **Down**, клик - увеличение/уменьшение на одну единицу, удержание нажатыми - непрерывное изменение опций; перебор опций и сохранение введенных данных - клик кнопкой **Set**;

Подробная инструкция по настройкам лежит [здесь](setting.md).

### Взаимодействие с внешним кодом

 Создавать объекты кнопок типа 
 ```
 shButton btnSet;
 ```
 не требуется, достаточно указать номера пинов, к которым они подключены, в файле **clockSetting.h** - библиотека создаст объекты кнопок сама, сама же их будет и опрашивать. Поэтому, если вам нужно обрабатывать события этих кнопок в своем коде, дублирование не требуется.

***ВАЖНО:** для корректной работы кнопок их опрос нельзя проводить более, чем один раз за один проход `loop()`. В противном случае есть риск пропуска событий кнопки.*

 Опрос кнопок ведется библиотекой в методе `tick()`. И для использования событий кнопок внешним кодом библиотека имеет соответствующие методы:
```
uint8_t getButtonState(clkButtonType _btn);
```
возвращает текущее состояние или событие кнопки, заданной параметром `_btn` по результату последнего опроса; `_btn` может принимать три значения:
 - `CLK_BTN_SET` - кнопка **Set**;
 - `CLK_BTN_UP` - кнопка **Up**;
 - `CLK_BTN_DOWN` - кнопка **Down**;
 
Возвращаемые данные соответствуют состояниям и событиям кнопки, используемым в библиотеке **shButton**.

Методы
```
clkButtonFlag getButtonFlag(clkButtonType _btnб bool _clear = false);
void setButtonFlag(clkButtonType _btn, clkButtonFlag _flag);
```
позволяют получить и установить соответственно текущие флаги кнопок; флаги могут принимать значения:
 - `CLK_BTN_FLAG_NONE` - флаг кнопки - ничего не делать;
 - `CLK_BTN_FLAG_NEXT` - флаг кнопки - изменить значение;
 - `CLK_BTN_FLAG_EXIT` - флаг кнопки - возврат в режим показа текущего времени;

Если параметр `_clear` в методе `getButtonFlag()` задать равным **true**, то флаг кнопки после считывания будет очищен (установлено значение **CLK_BTN_FLAG_NONE**);

Флаги используются для работы с интерфейсами настроек - времени, даты, будильника и всех доступных опций.
 
Образец обращения к кнопкам см. в примерах, [например](../examples/tm1637/tm1637.ino).

<hr>
 
### Смотри так же
- [Главная страница](../readme.md)
- [Используемые модули RTC](rtc.md)
- [Используемые в часах экраны](displays.md)
- Дополнительные опции:
  - [Календарь](calendar.md)
  - [Будильник](alarm.md)
  - [Регулировка уровней яркости экрана](br_adjust.md)
  - [Отображение температуры](show_temp.md)
  - [Опции для матричных экранов](matrix.md)
- Внешние датчики:
  - [Датчик освещенности](light_sensor.md)
  - [Датчики температуры](temp_sensors.md)
- [Описание файла `clockSetting.h`](clock_setting.md)
- [Взаимодействие с внешним кодом (API библиотеки)](api.md)
- [Руководство по настройкам часов](setting.md)
